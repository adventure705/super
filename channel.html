<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube 채널 관리 대시보드</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* 커스텀 스타일 및 다크 모드 */
        :root {
            font-family: 'Inter', sans-serif;
            --color-bg-primary: #111827; /* Dark Gray 900 */
            --color-text-primary: #f3f4f6; /* Light Gray 100 */
            --color-accent-primary: #4f46e5; /* Indigo 600 */
            --color-accent-secondary: #a5b4fc; /* Indigo 300 for hover text/links */
            --color-border: #374151; /* Gray 700 */
        }
        body {
            background-color: var(--color-bg-primary);
            color: var(--color-text-primary);
        }
        .container {
            max-width: 1400px;
        }
        .header-cell {
            cursor: pointer;
            padding: 0.75rem 0.5rem;
            text-align: left;
            user-select: none;
            transition: color 0.2s;
            white-space: nowrap;
        }
        .header-cell:hover {
            color: var(--color-accent-secondary);
        }
        .scrollable-table {
            overflow-x: auto;
            max-width: 100%;
            -webkit-overflow-scrolling: touch;
        }
        /* Tailwind configuration for custom colors/styles */
        .tailwind-config {
            @apply bg-gray-900 text-gray-100;
        }
        /* API 설정 버튼 위치 고정 */
        #api-settings-button {
             z-index: 40; /* 모달 아래, 다른 UI 위에 위치 */
        }
    </style>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, onSnapshot, collection, query, deleteDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase 및 전역 변수 설정
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // 데이터 경로는 artifacts/{appId}/public/data/{collectionName} 입니다.

        let app, db, auth;
        let isAuthReady = false;
        
        // --- API Key LocalStorage 초기화 및 상태 관리 헬퍼 ---
        const savedKeys = JSON.parse(localStorage.getItem('youtubeApiKeys')) || [];
        const activeName = localStorage.getItem('activeApiKeyName') || (savedKeys.length > 0 ? savedKeys[0].name : '');
        
        const getActiveApiKey = (keys, activeName) => keys.find(k => k.name === activeName)?.key || '';

        // 상태 관리
        window.state = {
            channels: [],
            categories: ['미분류'], // 사용자 정의 카테고리
            categoryColors: {}, // { '카테고리명': 'bg-red-700', ... }
            
            // API Key 새 구조
            apiKeys: savedKeys,
            activeApiKeyName: activeName,
            youtubeApiKey: getActiveApiKey(savedKeys, activeName), // Derived active key

            currentSort: { key: 'subscribers', direction: 'desc' },
            searchTerm: '',
            categoryFilter: '전체',
            ytCategoryFilter: '전체',
            isCategoryModalOpen: false,
            isApiModalOpen: false, // API 모달 상태 추가
            editingCategoryName: null,
            editingCategoryNewName: '',
            editingChannelMemoId: null,
            editingChannelMemoValue: '',
            
            // -- New states for channel category selection --
            editingChannelCategory: { id: null, current: null },
            isChannelCategoryModalOpen: false,
        };
        
        // LocalStorage 업데이트 및 상태 반영
        const updateApiStorage = () => {
            localStorage.setItem('youtubeApiKeys', JSON.stringify(window.state.apiKeys));
            localStorage.setItem('activeApiKeyName', window.state.activeApiKeyName);
            // Derived active key 업데이트
            window.state.youtubeApiKey = getActiveApiKey(window.state.apiKeys, window.state.activeApiKeyName);
            render();
        };

        // 카테고리 색상 매핑 보장 함수
        const ensureCategoryColors = () => {
            const palette = ['red', 'green', 'blue', 'yellow', 'purple', 'indigo', 'pink', 'teal'];
            const colorClasses = palette.map(p => `bg-${p}-700`);
            
            const newColors = { '미분류': 'bg-gray-700' };
            const usedColors = new Set(['bg-gray-700']);

            let colorIndex = 0;

            // 기존 색상 맵에 없는 카테고리에 색상 할당
            for (const cat of window.state.categories) {
                if (cat === '미분류') continue;

                if (!window.state.categoryColors[cat]) {
                    // 팔레트에서 아직 사용되지 않은 색상 찾기
                    let newColorClass = '';
                    while (colorIndex < colorClasses.length) {
                        const classCandidate = colorClasses[colorIndex];
                        if (!usedColors.has(classCandidate)) {
                            newColorClass = classCandidate;
                            break;
                        }
                        colorIndex++;
                    }
                    
                    // 팔레트 색상이 모두 사용되었다면 순환해서 재사용
                    if (!newColorClass) {
                        newColorClass = colorClasses[(colorIndex++) % colorClasses.length];
                    }
                    
                    newColors[cat] = newColorClass;
                    usedColors.add(newColorClass);
                } else {
                    // 기존 색상 유지
                    newColors[cat] = window.state.categoryColors[cat];
                    usedColors.add(newColors[cat]);
                }
            }
            
            window.state.categoryColors = newColors;
        };


        // UI 업데이트 함수 (렌더링)
        const render = () => {
            if (!isAuthReady) return;

            ensureCategoryColors(); // 카테고리가 변경될 때마다 색상 맵을 갱신
            
            const { channels, categories, currentSort, searchTerm, categoryFilter, ytCategoryFilter } = window.state;

            // 1. 필터링
            let filtered = channels.filter(channel => {
                const searchMatch = searchTerm.toLowerCase();
                
                // 검색어 필터 (리스트에 보이는 모든 필드 포함)
                const textContent = [
                    channel.channelName,
                    channel.note,
                    channel.country,
                    channel.customCategory,
                    channel.ytCategory,
                    channel.subscribers.toString(),
                    channel.totalViews.toString(),
                    channel.totalVideos.toString(),
                    new Date(channel.channelCreationDate).toLocaleDateString('ko-KR'),
                    new Date(channel.oldestVideoPostDate).toLocaleDateString('ko-KR'),
                    channel.avgUploadFreqDays.toString(),
                    channel.avgViews90d.toString(),
                    channel.avgLikes90d.toString(),
                    channel.avgComments90d.toString(),
                ].join(' ').toLowerCase();

                if (searchTerm && !textContent.includes(searchMatch)) return false;

                // 사용자 정의 카테고리 필터
                if (categoryFilter !== '전체' && channel.customCategory !== categoryFilter) return false;

                // YouTube 카테고리 필터
                if (ytCategoryFilter !== '전체' && channel.ytCategory !== ytCategoryFilter) return false;

                return true;
            });

            // 2. 정렬
            filtered.sort((a, b) => {
                const aVal = a[currentSort.key];
                const bVal = b[currentSort.key];

                let comparison = 0;
                if (aVal > bVal) comparison = 1;
                else if (aVal < bVal) comparison = -1;

                return currentSort.direction === 'asc' ? comparison : comparison * -1;
            });

            // 3. UI 렌더링
            renderTable(filtered);
            renderFilters(channels, categories);
            renderCategoryModal();
            renderApiSettingsModal(); // API 모달 렌더링 추가
            renderChannelCategorySelectionModal(); // 새 채널 카테고리 선택 모달 렌더링 추가
        };

        const renderTable = (channels) => {
            const tbody = document.getElementById('channel-list');
            if (!tbody) return;
            tbody.innerHTML = channels.map(channel => {
                // 구독자수, 조회수 등 숫자는 포맷팅
                const formatNumber = (num) => num.toLocaleString('ko-KR');

                // D-day 계산 (가장 오래된 영상 게시일로부터)
                const oldestVideoDate = channel.oldestVideoPostDate ? new Date(channel.oldestVideoPostDate) : null;
                const dDay = oldestVideoDate ? Math.floor((new Date() - oldestVideoDate) / (1000 * 60 * 60 * 24)) : 'N/A';
                
                // 카테고리 색상
                const categoryColorClass = window.state.categoryColors[channel.customCategory] || 'bg-gray-700';

                // 테이블 로우 HTML 생성
                return `
                    <tr class="border-b border-gray-700 hover:bg-gray-800 transition duration-150">
                        <!-- 채널명 및 프로필 아이콘 통합 -->
                        <td class="p-2 font-medium flex items-center space-x-2">
                            <img src="${channel.profileIconUrl}" alt="Profile" class="w-8 h-8 rounded-full object-cover">
                            <a href="${channel.channelUrl}" target="_blank" class="text-indigo-400 hover:text-indigo-300 transition">${channel.channelName}</a>
                        </td>
                        <!-- 채널링크 복사 버튼 -->
                        <td class="p-2">
                            <button onclick="window.copyToClipboard('${channel.channelUrl}')" class="text-gray-400 hover:text-indigo-400 transition" title="링크 복사">
                                <i data-lucide="copy" class="w-4 h-4"></i>
                            </button>
                        </td>
                        <!-- 카테고리 (사용자 정의) - 드롭다운 제거, 수정 버튼 추가 -->
                        <td class="p-2 whitespace-nowrap">
                            <div class="flex items-center space-x-2">
                                <span class="px-2 py-1 rounded-full text-xs font-semibold text-white ${categoryColorClass}">
                                    ${channel.customCategory}
                                </span>
                                <!-- 수정 버튼 추가: 드롭다운 대신 이 버튼으로 카테고리 변경 모달을 엽니다. -->
                                <button onclick="window.startCategorySelection('${channel.id}', '${channel.customCategory}')" 
                                        class="text-gray-400 hover:text-indigo-400 transition" 
                                        title="카테고리 변경">
                                    <i data-lucide="pencil-line" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </td>
                        <!-- YouTube 카테고리 -->
                        <td class="p-2 whitespace-nowrap">${channel.ytCategory || 'N/A'}</td>
                        <!-- 국가 -->
                        <td class="p-2 whitespace-nowrap">${channel.country || 'N/A'}</td>
                        <!-- 비고(메모) -->
                        <td class="p-2 min-w-40">
                            <span id="memo-display-${channel.id}" 
                                onclick="window.startMemoEdit('${channel.id}', '${channel.note.replace(/'/g, "\\'")}')" 
                                class="cursor-pointer hover:bg-gray-700 rounded-md p-1 block">
                                ${channel.note || '메모 추가...'}
                            </span>
                        </td>
                        <!-- 구독자 수 -->
                        <td class="p-2 whitespace-nowrap">${formatNumber(channel.subscribers)}</td>
                        <!-- 총 조회수 -->
                        <td class="p-2 whitespace-nowrap">${formatNumber(channel.totalViews)}</td>
                        <!-- 총 영상수 -->
                        <td class="p-2 whitespace-nowrap">${formatNumber(channel.totalVideos)}</td>
                        <!-- 채널 생성일 -->
                        <td class="p-2 whitespace-nowrap">${new Date(channel.channelCreationDate).toLocaleDateString('ko-KR')}</td>
                        <!-- 가장 오래된 영상 게시일 -->
                        <td class="p-2 whitespace-nowrap" title="D+${dDay}">${oldestVideoDate ? oldestVideoDate.toLocaleDateString('ko-KR') : 'N/A'}</td>
                        <!-- 평균 업로드 주기 -->
                        <td class="p-2 whitespace-nowrap">${channel.avgUploadFreqDays}일</td>
                        <!-- 90일 평균 조회수 -->
                        <td class="p-2 whitespace-nowrap">${formatNumber(channel.avgViews90d)}</td>
                        <!-- 90일 평균 좋아요 수 -->
                        <td class="p-2 whitespace-nowrap">${formatNumber(channel.avgLikes90d)}</td>
                        <!-- 16. 90일 평균 댓글 수 -->
                        <td class="p-2 whitespace-nowrap">${formatNumber(channel.avgComments90d)}</td>
                        <!-- 삭제 버튼 -->
                        <td class="p-2">
                             <button onclick="window.deleteChannel('${channel.id}')" class="text-red-400 hover:text-red-500 transition" title="채널 삭제">
                                <i data-lucide="trash-2" class="w-4 h-4"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('') || '<tr><td colspan="16" class="p-4 text-center text-gray-400">등록된 채널이 없습니다.</td></tr>';
            
            // Lucide 아이콘 다시 렌더링
            lucide.createIcons();
        };

        const renderFilters = (channels, categories) => {
            const filterContainer = document.getElementById('filter-container');
            if (!filterContainer) return;

            // 중복 없는 YouTube 카테고리 목록 생성
            const ytCategories = [...new Set(channels.map(c => c.ytCategory).filter(c => c))].sort();

            const customCategorySelect = document.getElementById('category-filter-select');
            const ytCategorySelect = document.getElementById('yt-category-filter-select');

            // 사용자 정의 카테고리 필터 업데이트
            customCategorySelect.innerHTML = `<option value="전체">전체 카테고리</option>` + categories.map(cat => 
                `<option value="${cat}" ${window.state.categoryFilter === cat ? 'selected' : ''}>${cat}</option>`
            ).join('');

            // YouTube 카테고리 필터 업데이트
            ytCategorySelect.innerHTML = `<option value="전체">전체 유튜브 카테고리</option>` + ytCategories.map(cat => 
                `<option value="${cat}" ${window.state.ytCategoryFilter === cat ? 'selected' : ''}>${cat}</option>`
            ).join('');
        };

        const renderCategoryModal = () => {
            const modal = document.getElementById('category-modal');
            if (!modal) return;
            modal.classList.toggle('hidden', !window.state.isCategoryModalOpen);

            if (window.state.isCategoryModalOpen) {
                const list = document.getElementById('category-list-body');
                list.innerHTML = window.state.categories.map(cat => {
                    const colorClass = window.state.categoryColors[cat] || 'bg-gray-700';
                    return `
                        <li class="flex justify-between items-center p-2 border-b border-gray-700 last:border-b-0 hover:bg-gray-800 rounded-md">
                            <span id="cat-name-${cat}" class="font-medium flex items-center space-x-2">
                                <span class="px-2 py-1 rounded-full text-xs font-semibold text-white ${colorClass}">${cat}</span>
                            </span>
                            <div class="flex space-x-2">
                                <button onclick="window.startCategoryEdit('${cat}')" class="text-indigo-400 hover:text-indigo-300 transition" title="이름 편집">
                                    <i data-lucide="pencil" class="w-4 h-4"></i>
                                </button>
                                <button onclick="window.deleteCategory('${cat}')" class="text-red-400 hover:text-red-500 transition" title="삭제">
                                    <i data-lucide="x" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </li>
                        ${window.state.editingCategoryName === cat ? `
                            <li class="p-2 flex space-x-2 bg-gray-700 rounded-b-md mb-2">
                                <input type="text" id="edit-cat-input" value="${window.state.editingCategoryNewName}" 
                                    class="flex-grow bg-gray-800 text-gray-100 border border-indigo-500 rounded-lg p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500">
                                <button onclick="window.saveCategoryEdit()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-3 rounded-lg text-sm transition">저장</button>
                                <button onclick="window.cancelCategoryEdit()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-1 px-3 rounded-lg text-sm transition">취소</button>
                            </li>
                        ` : ''}
                    `;
                }).join('');
                lucide.createIcons();
            }
        };

        const renderApiSettingsModal = () => {
            const modal = document.getElementById('api-settings-modal');
            if (!modal) return;
            modal.classList.toggle('hidden', !window.state.isApiModalOpen);
            
            if (window.state.isApiModalOpen) {
                 // API 키 목록 렌더링
                 const list = document.getElementById('api-key-list-body');
                 list.innerHTML = window.state.apiKeys.map(item => `
                    <li class="flex justify-between items-center p-3 border-b border-gray-700 last:border-b-0 hover:bg-gray-700 rounded-md transition duration-150 ${window.state.activeApiKeyName === item.name ? 'bg-indigo-900/50 border border-indigo-500' : ''}">
                        <div class="flex items-center space-x-3">
                            <input type="radio" name="active_key" value="${item.name}" 
                                id="key-radio-${item.name}" 
                                onchange="window.selectApiKey('${item.name}')"
                                ${window.state.activeApiKeyName === item.name ? 'checked' : ''}
                                class="form-radio h-4 w-4 text-indigo-500 bg-gray-600 border-gray-500 focus:ring-indigo-500 cursor-pointer">
                            <label for="key-radio-${item.name}" class="font-medium cursor-pointer">
                                ${item.name} 
                                <span class="text-xs text-gray-400 ml-2">(${item.key.substring(0, 4)}...${item.key.substring(item.key.length - 4)})</span>
                            </label>
                            ${window.state.activeApiKeyName === item.name ? '<span class="text-xs text-indigo-400 border border-indigo-400 px-1 rounded-full">활성</span>' : ''}
                        </div>
                        <button onclick="window.deleteApiKey('${item.name}')" class="text-red-400 hover:text-red-500 transition" title="삭제">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </li>
                 `).join('') || '<li class="p-3 text-center text-gray-400">저장된 API 키가 없습니다.</li>';
                 lucide.createIcons();
            }
        };

        const renderChannelCategorySelectionModal = () => {
            const modal = document.getElementById('channel-category-selection-modal');
            if (!modal) return;
            modal.classList.toggle('hidden', !window.state.isChannelCategoryModalOpen);

            if (window.state.isChannelCategoryModalOpen) {
                const { id, current } = window.state.editingChannelCategory;
                const channel = window.state.channels.find(c => c.id === id);
                if (!channel) return;
                
                document.getElementById('channel-category-title').textContent = `${channel.channelName} 채널 카테고리 변경`;
                
                const list = document.getElementById('channel-category-list');
                list.innerHTML = window.state.categories.map(cat => {
                    const colorClass = window.state.categoryColors[cat] || 'bg-gray-700';
                    return `
                        <li class="p-3 hover:bg-gray-700/70 rounded-lg cursor-pointer flex items-center space-x-3 transition duration-150">
                            <input type="radio" name="new_category_select" id="cat-select-${cat}" value="${cat}"
                                ${current === cat ? 'checked' : ''}
                                class="form-radio h-4 w-4 text-indigo-500 bg-gray-600 border-gray-500 focus:ring-indigo-500 cursor-pointer">
                            <label for="cat-select-${cat}" class="flex items-center space-x-2 font-medium w-full cursor-pointer">
                                <span class="px-2 py-1 rounded-full text-xs font-semibold text-white ${colorClass}">${cat}</span>
                            </label>
                        </li>
                    `;
                }).join('');
            }
        };

        const renderMemoModal = () => {
             const modal = document.getElementById('memo-modal');
            if (!modal) return;
            modal.classList.toggle('hidden', !window.state.editingChannelMemoId);

            if (window.state.editingChannelMemoId) {
                document.getElementById('memo-input').value = window.state.editingChannelMemoValue;
                // 포커스 설정
                setTimeout(() => document.getElementById('memo-input').focus(), 100);
            }
        }
        
        window.render = render; // 전역 노출

        // --- Firebase CRUD Functions ---

        // Firebase 초기화 및 인증
        const setupFirebase = async () => {
            if (!firebaseConfig) {
                console.error("Firebase config is not available.");
                document.getElementById('initial-loading').textContent = "Firebase 설정이 필요합니다.";
                return;
            }
            try {
                // setLogLevel('debug'); // 디버그 로그 활성화
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // 인증 처리 (익명 로그인 또는 커스텀 토큰 로그인)
                await new Promise(resolve => {
                    onAuthStateChanged(auth, async (user) => {
                        if (!user) {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                        }
                        isAuthReady = true;
                        resolve();
                    });
                });

                document.getElementById('user-id-display').textContent = `데이터 저장 경로: /artifacts/${appId}/public/data/...`;
                
                // Firestore 리스너 설정
                setupListeners();

            } catch (error) {
                console.error("Firebase 초기화 또는 인증 오류:", error);
                document.getElementById('initial-loading').textContent = `초기화 오류: ${error.message}`;
            }
        };

        // 데이터 리스너 설정
        const setupListeners = () => {
            if (!isAuthReady) return;

            // 1. 채널 목록 리스너: 공개(Public) 경로를 사용합니다.
            const channelsCollection = collection(db, `artifacts/${appId}/public/data/channels`);
            onSnapshot(channelsCollection, (snapshot) => {
                window.state.channels = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                render();
            }, (error) => {
                console.error("채널 데이터 리스너 오류:", error);
            });

            // 2. 카테고리 목록 리스너 (단일 문서): 공개(Public) 경로를 사용합니다.
            const categoriesDocRef = doc(db, `artifacts/${appId}/public/data/categories`, 'customCategories');
            onSnapshot(categoriesDocRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    window.state.categories = docSnapshot.data().names || ['미분류'];
                } else {
                    // 문서가 없으면 기본값으로 생성
                    setDoc(categoriesDocRef, { names: ['미분류'] });
                    window.state.categories = ['미분류'];
                }
                render();
            }, (error) => {
                console.error("카테고리 데이터 리스너 오류:", error);
            });
        };

        // --- Mock YouTube API Function (TODO: Replace with actual API Call) ---
        const fetchYouTubeData = (url) => {
            // API Key가 없으면 경고
            if (!window.state.youtubeApiKey) {
                throw new Error("YouTube API Key가 설정되지 않았습니다. API 설정 모달을 통해 키를 입력해주세요.");
            }
            
            // 실제 API에서 가져와야 하는 데이터 필드 (Mock)
            const mockName = `모의 채널 ${Math.floor(Math.random() * 100)}`;
            
            return {
                channelUrl: url,
                profileIconUrl: `https://placehold.co/40x40/6A0DAD/EAEAEA?text=${mockName.charAt(0)}`,
                channelName: mockName,
                ytCategory: ['음악', '게임', '코미디', '교육'][Math.floor(Math.random() * 4)],
                country: ['KR', 'US', 'JP'][Math.floor(Math.random() * 3)],
                subscribers: Math.floor(Math.random() * 10000000),
                totalViews: Math.floor(Math.random() * 500000000),
                totalVideos: Math.floor(Math.random() * 2000),
                channelCreationDate: new Date(Date.now() - Math.floor(Math.random() * 5 * 365 * 24 * 60 * 60 * 1000)).toISOString(),
                oldestVideoPostDate: new Date(Date.now() - Math.floor(Math.random() * 3 * 365 * 24 * 60 * 60 * 1000)).toISOString(),
                avgUploadFreqDays: Math.floor(Math.random() * 30) + 1,
                avgViews90d: Math.floor(Math.random() * 100000),
                avgLikes90d: Math.floor(Math.random() * 5000),
                avgComments90d: Math.floor(Math.random() * 500),
                note: '',
                customCategory: '미분류',
                channelId: 'MOCK_ID',
            };
        };


        // --- Event Handlers (Globalized for HTML calls) ---

        // API 설정 모달 열기/닫기
        window.toggleApiSettingsModal = (open) => {
            window.state.isApiModalOpen = open;
            render();
        };

        // 새 API 키 추가
        window.addApiKey = () => {
            const nameInput = document.getElementById('new-api-name-input');
            const keyInput = document.getElementById('new-api-key-input');
            const name = nameInput.value.trim();
            const key = keyInput.value.trim();

            if (!name || !key) {
                alertModal("경고", "키 이름과 API 키를 모두 입력해주세요.");
                return;
            }

            if (window.state.apiKeys.some(k => k.name === name)) {
                alertModal("경고", `"${name}" 이름의 키가 이미 존재합니다.`);
                return;
            }
            
            // 키 추가
            window.state.apiKeys.push({ name, key });
            
            // 처음 추가 시 활성화
            if (window.state.apiKeys.length === 1) {
                window.state.activeApiKeyName = name;
            }

            updateApiStorage();
            nameInput.value = '';
            keyInput.value = '';
            alertModal("성공", `API 키 "${name}"이(가) 저장되었습니다.`);
        };

        // 활성 API 키 선택
        window.selectApiKey = (name) => {
            window.state.activeApiKeyName = name;
            updateApiStorage();
            alertModal("활성 키 변경", `활성 API 키가 "${name}"(으)로 변경되었습니다.`);
        };

        // API 키 삭제
        window.deleteApiKey = (name) => {
            if (name === window.state.activeApiKeyName) {
                alertModal("경고", "활성화된 API 키는 삭제할 수 없습니다. 다른 키를 선택한 후 삭제해주세요.");
                return;
            }
            
            if (window.state.apiKeys.length === 1 && name === window.state.apiKeys[0].name) {
                 alertModal("경고", "마지막 남은 키는 삭제할 수 없습니다.");
                 return;
            }
            
            if (window.state.apiKeys.length === 1) {
                 window.state.apiKeys = []; // 마지막 키 삭제
                 window.state.activeApiKeyName = '';
            } else {
                 window.state.apiKeys = window.state.apiKeys.filter(k => k.name !== name);
            }

            updateApiStorage();
            alertModal("삭제 완료", `API 키 "${name}"이(가) 삭제되었습니다.`);
        };
        
        // 채널 추가
        window.handleAddChannel = async (event) => {
            event.preventDefault();
            const urlInput = document.getElementById('youtube-url-input');
            const url = urlInput.value.trim();

            if (!url) {
                alertModal("경고", "유튜브 채널 URL을 입력해주세요.");
                return;
            }
            
            if (!window.state.youtubeApiKey) {
                alertModal("경고", "활성화된 YouTube API Key가 없습니다. API 설정에서 키를 등록/선택하세요.");
                return;
            }

            // 모달 표시
            const addModal = document.getElementById('add-channel-loading-modal');
            addModal.classList.remove('hidden');

            try {
                // 1. YouTube API로 데이터 가져오기 (TODO: 실제 API 호출로 교체)
                const channelData = fetchYouTubeData(url);
                
                // 2. Firestore에 저장: 공개(Public) 경로를 사용합니다.
                const channelsCollection = collection(db, `artifacts/${appId}/public/data/channels`);
                await addDoc(channelsCollection, {
                    ...channelData,
                    addedDate: new Date().toISOString(),
                    // Firestore 정렬을 위해 숫자형 필드를 명시적으로 저장
                    subscribers: channelData.subscribers,
                    totalViews: channelData.totalViews,
                    totalVideos: channelData.totalVideos,
                });

                urlInput.value = ''; // 성공 시 입력 필드 초기화
                alertModal("성공", `${channelData.channelName} 채널이 목록에 추가되었습니다.`);

            } catch (error) {
                console.error("채널 추가 오류:", error);
                alertModal("오류", `채널 추가 중 오류가 발생했습니다: ${error.message}`);
            } finally {
                addModal.classList.add('hidden'); // 모달 숨김
            }
        };
        
        // 정렬 처리
        window.handleSort = (key) => {
            const current = window.state.currentSort;
            let direction = 'desc';

            if (current.key === key) {
                direction = current.direction === 'desc' ? 'asc' : 'desc';
            }

            window.state.currentSort = { key, direction };
            render();
        };

        // 검색어 변경
        window.handleSearchChange = (event) => {
            window.state.searchTerm = event.target.value;
            render();
        };

        // 필터 변경
        window.handleFilterChange = (type, value) => {
            if (type === 'custom') {
                window.state.categoryFilter = value;
            } else if (type === 'yt') {
                window.state.ytCategoryFilter = value;
            }
            render();
        };

        // 카테고리 (Firestore 저장만 담당)
        window.handleCategoryChange = async (channelId, newCategory) => {
            try {
                // 공개(Public) 경로를 사용합니다.
                const channelRef = doc(db, `artifacts/${appId}/public/data/channels`, channelId);
                await updateDoc(channelRef, { customCategory: newCategory });
            } catch (error) {
                console.error("카테고리 업데이트 오류:", error);
                // 모달 내에서는 오류를 던져서 상위 함수에서 처리하도록 합니다.
                throw new Error("카테고리 업데이트 중 오류가 발생했습니다.");
            }
        };
        
        // 카테고리 선택 모달 시작
        window.startCategorySelection = (id, current) => {
            window.state.editingChannelCategory = { id, current };
            window.state.isChannelCategoryModalOpen = true;
            render();
        };

        // 카테고리 선택 모달 취소
        window.cancelChannelCategorySelection = () => {
            window.state.editingChannelCategory = { id: null, current: null };
            window.state.isChannelCategoryModalOpen = false;
            render();
        };
        
        // 카테고리 선택 저장
        window.saveChannelCategorySelection = async () => {
            const id = window.state.editingChannelCategory.id;
            const selectedRadio = document.querySelector('input[name="new_category_select"]:checked');
            
            if (!id || !selectedRadio) {
                window.cancelChannelCategorySelection();
                return;
            }
            
            const newCategory = selectedRadio.value;
            
            try {
                // 기존 handleCategoryChange 로직 재사용
                await window.handleCategoryChange(id, newCategory);
                alertModal("저장 완료", `채널 카테고리가 '${newCategory}'(으)로 변경되었습니다.`);
            } catch (error) {
                console.error("카테고리 업데이트 오류:", error); 
                alertModal("오류", "카테고리 업데이트 중 오류가 발생했습니다.");
            } finally {
                window.cancelChannelCategorySelection();
            }
        };


        // 채널 삭제
        window.deleteChannel = async (channelId) => {
            if (await customConfirm("채널 삭제", "정말로 이 채널을 목록에서 삭제하시겠습니까?")) {
                 try {
                    // 공개(Public) 경로를 사용합니다.
                    const channelRef = doc(db, `artifacts/${appId}/public/data/channels`, channelId);
                    await deleteDoc(channelRef);
                    alertModal("삭제 완료", "채널이 목록에서 삭제되었습니다.");
                } catch (error) {
                    console.error("채널 삭제 오류:", error);
                    alertModal("오류", "채널 삭제 중 오류가 발생했습니다.");
                }
            }
        }
        
        // 메모 편집 시작
        window.startMemoEdit = (id, currentValue) => {
            // 주의: HTML 속성에 따옴표가 포함될 경우 인코딩 필요
            window.state.editingChannelMemoId = id;
            window.state.editingChannelMemoValue = currentValue.replace(/\\'/g, "'");
            renderMemoModal();
        }

        // 메모 편집 저장
        window.saveMemoEdit = async () => {
            const id = window.state.editingChannelMemoId;
            const newValue = document.getElementById('memo-input').value.trim();

            if (!id) {
                window.state.editingChannelMemoId = null;
                renderMemoModal();
                return;
            }

            try {
                // 공개(Public) 경로를 사용합니다.
                const channelRef = doc(db, `artifacts/${appId}/public/data/channels`, id);
                // 빈 문자열도 저장 가능하도록 수정
                await updateDoc(channelRef, { note: newValue });
                window.state.editingChannelMemoId = null;
                alertModal("저장 완료", "메모가 업데이트되었습니다.");
            } catch (error) {
                console.error("메모 업데이트 오류:", error);
                alertModal("오류", "메모 업데이트 중 오류가 발생했습니다.");
            } finally {
                renderMemoModal();
            }
        }

        // 메모 편집 취소
        window.cancelMemoEdit = () => {
            window.state.editingChannelMemoId = null;
            renderMemoModal();
        }

        // 카테고리 관리 모달 열기/닫기
        window.toggleCategoryModal = (open) => {
            window.state.isCategoryModalOpen = open;
            window.state.editingCategoryName = null; // 편집 상태 초기화
            render();
        };

        // 새 카테고리 추가
        window.addCategory = async () => {
            const input = document.getElementById('new-category-input');
            const newCat = input.value.trim();
            if (!newCat || window.state.categories.includes(newCat)) return;

            try {
                // 공개(Public) 경로를 사용합니다.
                const categoriesDocRef = doc(db, `artifacts/${appId}/public/data/categories`, 'customCategories');
                await setDoc(categoriesDocRef, { names: [...window.state.categories, newCat] }, { merge: true });
                input.value = '';
            } catch (error) {
                console.error("카테고리 추가 오류:", error);
                alertModal("오류", "카테고리 추가 중 오류가 발생했습니다.");
            }
        };

        // 카테고리 편집 시작
        window.startCategoryEdit = (name) => {
            window.state.editingCategoryName = name;
            window.state.editingCategoryNewName = name;
            render();
        };

        // 카테고리 편집 취소
        window.cancelCategoryEdit = () => {
            window.state.editingCategoryName = null;
            window.state.editingCategoryNewName = '';
            render();
        };

        // 카테고리 편집 저장 (이름 변경)
        window.saveCategoryEdit = async () => {
            const oldName = window.state.editingCategoryName;
            const newName = document.getElementById('edit-cat-input').value.trim();

            if (!oldName || !newName || oldName === newName || window.state.categories.includes(newName)) {
                alertModal("경고", "유효하지 않거나 이미 존재하는 카테고리 이름입니다.");
                return;
            }
            
            // 1. Firestore의 카테고리 목록 업데이트: 공개(Public) 경로를 사용합니다.
            const newCategories = window.state.categories.map(cat => cat === oldName ? newName : cat);
            const categoriesDocRef = doc(db, `artifacts/${appId}/public/data/categories`, 'customCategories');
            
            // 2. 모든 채널 문서에서 해당 카테고리 이름 업데이트: 공개(Public) 경로를 사용합니다.
            const batchPromises = window.state.channels
                .filter(c => c.customCategory === oldName)
                .map(c => {
                    const channelRef = doc(db, `artifacts/${appId}/public/data/channels`, c.id);
                    return updateDoc(channelRef, { customCategory: newName });
                });

            try {
                // 카테고리 이름 목록 저장
                await setDoc(categoriesDocRef, { names: newCategories });
                // 채널 업데이트 배치 처리 (업데이트는 리스너로 자동 반영됨)
                await Promise.all(batchPromises);
                
                alertModal("성공", `'${oldName}' 카테고리가 '${newName}'으로 변경되었습니다.`);
            } catch (error) {
                console.error("카테고리 이름 변경 오류:", error);
                alertModal("오류", "카테고리 이름 변경 중 오류가 발생했습니다.");
            } finally {
                window.state.editingCategoryName = null;
                window.state.editingCategoryNewName = '';
                render();
            }
        };

        // 카테고리 삭제
        window.deleteCategory = async (name) => {
            if (name === '미분류') {
                alertModal("경고", "'미분류' 카테고리는 삭제할 수 없습니다.");
                return;
            }
            
            if (await customConfirm("카테고리 삭제", `'${name}' 카테고리를 삭제하시겠습니까? 이 카테고리에 할당된 모든 채널은 '미분류'로 자동 변경됩니다.`)) {
                
                // 1. 카테고리 목록에서 제거: 공개(Public) 경로를 사용합니다.
                const newCategories = window.state.categories.filter(cat => cat !== name);
                const categoriesDocRef = doc(db, `artifacts/${appId}/public/data/categories`, 'customCategories');

                // 2. 모든 채널 문서에서 해당 카테고리 '미분류'로 업데이트: 공개(Public) 경로를 사용합니다.
                const batchPromises = window.state.channels
                    .filter(c => c.customCategory === name)
                    .map(c => {
                        const channelRef = doc(db, `artifacts/${appId}/public/data/channels`, c.id);
                        return updateDoc(channelRef, { customCategory: '미분류' });
                    });
                
                try {
                    await setDoc(categoriesDocRef, { names: newCategories });
                    await Promise.all(batchPromises);
                    alertModal("삭제 완료", `'${name}' 카테고리가 삭제되고 관련 채널이 '미분류'로 재할당되었습니다.`);
                } catch (error) {
                    console.error("카테고리 삭제 오류:", error);
                    alertModal("오류", "카테고리 삭제 중 오류가 발생했습니다.");
                }
            }
        }
        
        // --- Utility Functions ---

        // 클립보드 복사
        window.copyToClipboard = (text) => {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                alertModal("복사 완료", "링크가 클립보드에 복사되었습니다.");
            } catch (err) {
                console.error('클립보드 복사 실패:', err);
                alertModal("복사 실패", "클립보드 복사에 실패했습니다.");
            }
            document.body.removeChild(textarea);
        };
        
        // 커스텀 Confirm 모달
        const customConfirm = (title, message) => {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirm-modal');
                const titleEl = document.getElementById('confirm-title');
                const messageEl = document.getElementById('confirm-message');
                const confirmBtn = document.getElementById('confirm-yes-btn');
                const cancelBtn = document.getElementById('confirm-no-btn');
                
                titleEl.textContent = title;
                messageEl.textContent = message;
                modal.classList.remove('hidden');

                const cleanup = () => {
                    modal.classList.add('hidden');
                    confirmBtn.removeEventListener('click', onConfirm);
                    cancelBtn.removeEventListener('click', onCancel);
                };

                const onConfirm = () => {
                    cleanup();
                    resolve(true);
                };

                const onCancel = () => {
                    cleanup();
                    resolve(false);
                };

                confirmBtn.addEventListener('click', onConfirm);
                cancelBtn.addEventListener('click', onCancel);
            });
        };

        // 커스텀 Alert 모달
        window.alertModal = (title, message) => {
            const modal = document.getElementById('alert-modal');
            document.getElementById('alert-title').textContent = title;
            document.getElementById('alert-message').textContent = message;
            modal.classList.remove('hidden');

            document.getElementById('alert-close-btn').onclick = () => {
                modal.classList.add('hidden');
            };
        };

        // 페이지 로드 시 Firebase 초기화
        window.onload = setupFirebase;
    </script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-4 sm:p-8">

    <div class="container mx-auto">
        <div class="flex justify-between items-start mb-6">
             <h1 class="text-3xl font-extrabold text-white">YouTube 채널 관리 대시보드</h1>
             <!-- API 설정 버튼 (우측 상단) -->
             <button id="api-settings-button" onclick="window.toggleApiSettingsModal(true)" 
                     class="bg-gray-700 hover:bg-gray-600 text-indigo-300 font-bold py-2 px-4 rounded-lg transition duration-200 whitespace-nowrap flex items-center shadow-md">
                 <i data-lucide="key" class="w-5 h-5 mr-1"></i> API 설정
             </button>
        </div>

        <div id="initial-loading" class="text-center p-8 text-indigo-400 font-medium hidden">
             <i data-lucide="loader" class="w-6 h-6 animate-spin inline-block mr-2"></i> 로딩 중...
        </div>
        
        <!-- 데이터 저장 경로 표시 업데이트 -->
        <div class="text-sm text-gray-500 mb-4" id="user-id-display"></div>

        <!-- 상단 컨트롤 섹션 (UI 재구성) -->
        <div class="flex flex-col space-y-4 mb-8">
            
            <!-- Row 1: 유튜브 링크 입력 및 추가 (단독 한 줄) -->
            <form id="add-channel-form" onsubmit="window.handleAddChannel(event)" class="flex space-x-2">
                <input type="url" id="youtube-url-input" placeholder="유튜브 채널 URL 입력" required
                       class="flex-grow bg-gray-800 text-gray-100 border border-gray-700 rounded-lg p-3 focus:ring-indigo-500 focus:border-indigo-500 placeholder:text-gray-500">
                <button type="submit" class="bg-indigo-700 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-md flex-shrink-0">
                    <i data-lucide="plus" class="w-5 h-5"></i>
                </button>
            </form>

            <!-- Row 2: 검색 바 (단독 한 줄) -->
            <div class="flex items-center space-x-2">
                <i data-lucide="search" class="w-5 h-5 text-gray-400"></i>
                <input type="text" id="search-input" oninput="window.handleSearchChange(event)" placeholder="채널명, 메모, 국가, 카테고리 등 전체 리스트 검색"
                       class="w-full bg-gray-800 text-gray-100 border border-gray-700 rounded-lg p-3 focus:ring-indigo-500 focus:border-indigo-500 placeholder:text-gray-500">
            </div>
            
            <!-- Row 3: 카테고리 필터 및 관리 (PC에서 오른쪽 정렬) -->
            <div id="filter-container" class="flex flex-wrap gap-4 items-center justify-start md:justify-end">
                
                <!-- 사용자 정의 카테고리 필터 -->
                <div class="flex items-center space-x-2">
                    <label for="category-filter-select" class="text-gray-300 whitespace-nowrap text-sm">카테고리 필터:</label>
                    <select id="category-filter-select" onchange="window.handleFilterChange('custom', this.value)"
                            class="bg-gray-800 text-gray-100 border border-gray-700 rounded-lg p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500 min-w-[120px]">
                        <!-- Options populated by JS -->
                    </select>
                </div>
                

                <!-- YouTube 카테고리 필터 -->
                <div class="flex items-center space-x-2">
                    <label for="yt-category-filter-select" class="text-gray-300 whitespace-nowrap text-sm">유튜브 카테고리:</label>
                    <select id="yt-category-filter-select" onchange="window.handleFilterChange('yt', this.value)"
                            class="bg-gray-800 text-gray-100 border border-gray-700 rounded-lg p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500 min-w-[120px]">
                        <!-- Options populated by JS -->
                    </select>
                </div>

                <!-- 카테고리 편집 버튼 -->
                <button onclick="window.toggleCategoryModal(true)" class="bg-indigo-700 hover:bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg transition duration-200 whitespace-nowrap text-sm flex items-center">
                    <i data-lucide="settings" class="w-4 h-4 inline-block mr-1"></i> 카테고리 편집
                </button>
            </div>
        </div>

        <!-- 채널 목록 테이블 -->
        <div class="bg-gray-800 rounded-xl shadow-lg mt-8 p-4">
            <div class="scrollable-table">
                <table class="min-w-full divide-y divide-gray-700 text-sm">
                    <thead class="bg-gray-700 sticky top-0 z-10">
                        <tr>
                            <!-- 1. 채널명 (아이콘 통합) -->
                            <th class="header-cell" onclick="window.handleSort('channelName')">채널명</th>
                            <!-- 2. 채널링크 복사 버튼 (정렬 불가) -->
                            <th class="header-cell p-2"></th>
                            <!-- 3. 카테고리 (사용자 정의) -->
                            <th class="header-cell" onclick="window.handleSort('customCategory')">카테고리</th>
                            <!-- 4. 유튜브 카테고리 -->
                            <th class="header-cell" onclick="window.handleSort('ytCategory')">유튜브 카테고리</th>
                            <!-- 5. 국가 -->
                            <th class="header-cell" onclick="window.handleSort('country')">국가</th>
                            <!-- 6. 비고(메모) -->
                            <th class="header-cell" onclick="window.handleSort('note')">비고(메모)</th>
                            <!-- 7. 구독자 수 -->
                            <th class="header-cell" onclick="window.handleSort('subscribers')">구독자 수</th>
                            <!-- 8. 총 조회수 -->
                            <th class="header-cell" onclick="window.handleSort('totalViews')">총 조회수</th>
                            <!-- 9. 총 영상수 -->
                            <th class="header-cell" onclick="window.handleSort('totalVideos')">총 영상수</th>
                            <!-- 10. 채널 생성일 -->
                            <th class="header-cell" onclick="window.handleSort('channelCreationDate')">채널 생성일</th>
                            <!-- 11. 가장 오래된 영상 게시일 -->
                            <th class="header-cell" onclick="window.handleSort('oldestVideoPostDate')">가장 오래된 영상 게시일</th>
                            <!-- 12. 평균 업로드 주기 -->
                            <th class="header-cell" onclick="window.handleSort('avgUploadFreqDays')">평균 업로드 주기(일)</th>
                            <!-- 13. 90일 평균 조회수 -->
                            <th class="header-cell" onclick="window.handleSort('avgViews90d')">90일 평균 조회수</th>
                            <!-- 14. 90일 평균 좋아요 수 -->
                            <th class="header-cell" onclick="window.handleSort('avgLikes90d')">90일 평균 좋아요</th>
                            <!-- 15. 90일 평균 댓글 수 -->
                            <th class="header-cell" onclick="window.handleSort('avgComments90d')">90일 평균 댓글 수</th>
                            <!-- 16. 삭제 버튼 (정렬 불가) -->
                            <th class="header-cell p-2"></th>
                        </tr>
                    </thead>
                    <tbody id="channel-list" class="divide-y divide-gray-800">
                        <!-- 채널 데이터는 JS에서 렌더링됩니다. -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- 모달: API 설정 (멀티 키 관리) -->
    <div id="api-settings-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 w-11/12 max-w-lg">
            <div class="flex justify-between items-center border-b border-gray-700 pb-3 mb-4">
                <h3 class="text-xl font-bold text-white">YouTube API 키 관리</h3>
                <button onclick="window.toggleApiSettingsModal(false)" class="text-gray-400 hover:text-white">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            
            <p class="text-sm text-gray-400 mb-4">
                YouTube Data API 키를 등록하고 사용할 키를 선택하세요.
                현재 활성 키: <span class="font-bold text-indigo-400">${window.state.activeApiKeyName || '선택 안됨'}</span>
            </p>

            <!-- 새 키 추가 섹션 -->
            <div class="mb-6 p-4 bg-gray-700/50 rounded-lg">
                 <h4 class="text-lg font-semibold mb-3 border-b border-gray-600 pb-2">새 API 키 등록</h4>
                <div class="flex flex-col space-y-3">
                    <input type="text" id="new-api-name-input" placeholder="API 키 이름 (예: 개인 키, 백업 키)" 
                           class="w-full bg-gray-900 text-gray-100 border border-gray-700 rounded-lg p-2 focus:ring-indigo-500 focus:border-indigo-500">
                    <input type="text" id="new-api-key-input" placeholder="YouTube Data API Key" 
                           class="w-full bg-gray-900 text-gray-100 border border-gray-700 rounded-lg p-2 focus:ring-indigo-500 focus:border-indigo-500">
                    <div class="flex justify-end">
                        <button onclick="window.addApiKey()" class="bg-indigo-700 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition">키 추가 및 저장</button>
                    </div>
                </div>
            </div>

            <!-- 저장된 키 목록 섹션 -->
            <h4 class="text-lg font-semibold mb-3 mt-6 border-b border-gray-700 pb-2">저장된 키 목록 (활성 키 선택)</h4>
            <ul id="api-key-list-body" class="max-h-64 overflow-y-auto divide-y divide-gray-700">
                <!-- API 키 목록은 JS에서 렌더링됩니다. -->
            </ul>

            <div class="flex justify-end space-x-3 mt-4">
                <button onclick="window.toggleApiSettingsModal(false)" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition">닫기</button>
            </div>
        </div>
    </div>

    <!-- 모달: 채널 카테고리 선택 (새로 추가) -->
    <div id="channel-category-selection-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 w-11/12 max-w-sm">
            <div class="flex justify-between items-center border-b border-gray-700 pb-3 mb-4">
                <h3 id="channel-category-title" class="text-xl font-bold text-white">채널 카테고리 변경</h3>
                <button onclick="window.cancelChannelCategorySelection()" class="text-gray-400 hover:text-white">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            
            <ul id="channel-category-list" class="max-h-64 overflow-y-auto divide-y divide-gray-700 pr-2">
                <!-- 카테고리 목록은 JS에서 렌더링됩니다. -->
            </ul>
            
            <div class="flex justify-end space-x-3 mt-4 border-t border-gray-700 pt-3">
                <button onclick="window.cancelChannelCategorySelection()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition">취소</button>
                <button onclick="window.saveChannelCategorySelection()" class="bg-indigo-700 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition">저장</button>
            </div>
        </div>
    </div>

    <!-- 모달: 카테고리 편집 -->
    <div id="category-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 w-11/12 max-w-lg">
            <div class="flex justify-between items-center border-b border-gray-700 pb-3 mb-4">
                <h3 class="text-xl font-bold text-white">카테고리 편집</h3>
                <button onclick="window.toggleCategoryModal(false)" class="text-gray-400 hover:text-white">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            
            <div class="mb-4">
                <h4 class="text-lg font-semibold mb-2">새 카테고리 추가</h4>
                <div class="flex space-x-2">
                    <input type="text" id="new-category-input" placeholder="새 카테고리 이름" 
                           class="flex-grow bg-gray-900 text-gray-100 border border-gray-700 rounded-lg p-2 focus:ring-indigo-500 focus:border-indigo-500">
                    <button onclick="window.addCategory()" class="bg-indigo-700 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition">추가</button>
                </div>
            </div>

            <h4 class="text-lg font-semibold mb-2 mt-6 border-t border-gray-700 pt-4">기존 카테고리 목록</h4>
            <ul id="category-list-body" class="max-h-64 overflow-y-auto divide-y divide-gray-700 pr-2">
                <!-- 카테고리 목록은 JS에서 렌더링됩니다. -->
            </ul>
        </div>
    </div>
    
    <!-- 모달: 비고(메모) 편집 -->
    <div id="memo-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 w-11/12 max-w-lg">
            <div class="flex justify-between items-center border-b border-gray-700 pb-3 mb-4">
                <h3 class="text-xl font-bold text-white">비고(메모) 편집</h3>
                <button onclick="window.cancelMemoEdit()" class="text-gray-400 hover:text-white">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            
            <textarea id="memo-input" rows="4" placeholder="메모를 입력하세요..." 
                      class="w-full bg-gray-900 text-gray-100 border border-gray-700 rounded-lg p-3 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
            
            <div class="flex justify-end space-x-3 mt-4">
                <button onclick="window.cancelMemoEdit()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition">취소</button>
                <button onclick="window.saveMemoEdit()" class="bg-indigo-700 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition">저장</button>
            </div>
        </div>
    </div>
    
    <!-- 모달: 채널 추가 로딩 -->
    <div id="add-channel-loading-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 flex items-center space-x-3">
            <i data-lucide="loader" class="w-6 h-6 animate-spin text-indigo-400"></i>
            <span class="text-white font-medium">채널 정보를 불러오는 중...</span>
        </div>
    </div>

    <!-- 모달: Alert (경고/성공 메시지) -->
    <div id="alert-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 w-11/12 max-w-sm">
            <h3 id="alert-title" class="text-xl font-bold text-white border-b border-gray-700 pb-2 mb-3"></h3>
            <p id="alert-message" class="text-gray-300 mb-4"></p>
            <div class="flex justify-end">
                <button id="alert-close-btn" class="bg-indigo-700 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition">확인</button>
            </div>
        </div>
    </div>
    
    <!-- 모달: Confirm (확인/취소 메시지) -->
    <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 w-11/12 max-w-sm">
            <h3 id="confirm-title" class="text-xl font-bold text-white border-b border-gray-700 pb-2 mb-3"></h3>
            <p id="confirm-message" class="text-gray-300 mb-4"></p>
            <div class="flex justify-end space-x-3">
                <button id="confirm-no-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition">취소</button>
                <button id="confirm-yes-btn" class="bg-red-700 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition">확인</button>
            </div>
        </div>
    </div>

    <script>
        // 페이지 로드 시 initial-loading 요소 보이기
        document.addEventListener('DOMContentLoaded', () => {
             // Firebase 초기화 전에 로딩 표시
             document.getElementById('initial-loading').classList.remove('hidden');
        });
    </script>
</body>
</html>